This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-13T18:48:31.488Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
pyrosim/
  collisionsdf.py
  collisionurdf.py
  commonFunctions.py
  constants.py
  geometrysdf.py
  geometryurdf.py
  inertialsdf.py
  inertialurdf.py
  inertiasdf.py
  inertiaurdf.py
  joint.py
  linksdf.py
  linkurdf.py
  masssdf.py
  massurdf.py
  material.py
  model.py
  neuralNetwork.py
  neuron.py
  nndf.py
  originurdf.py
  pyrosim.py
  README.md
  robot.py
  sdf.py
  synapse.py
  urdf.py
  visualsdf.py
  visualurdf.py
scripts/
  analyze.py
  constants.py
  generate.py
  hillclimber.py
  motor.py
  robot.py
  search.py
  sensor.py
  simulate.py
  simulation.py
  solution.py
  world.py
.gitignore
LICENSE
pylintrc
README.md
requirements.txt
setup.py

================================================================
Repository Files
================================================================

================
File: pyrosim/collisionsdf.py
================
from pyrosim.commonFunctions import Save_Whitespace

class COLLISION_SDF: 

    def __init__(self,geometry):

        self.geometry = geometry
 
        self.depth = 3

    def Save(self,f):

        self.Save_Start_Tag(f)

        self.geometry.Save(f)

        self.Save_End_Tag(f)

# ------------------ Private methods ------------------

    def Save_End_Tag(self,f):

        Save_Whitespace(self.depth,f)

        f.write('</collision>\n')

    def Save_Start_Tag(self,f):

        Save_Whitespace(self.depth,f)

        f.write('<collision>\n')

================
File: pyrosim/collisionurdf.py
================
from pyrosim.commonFunctions import Save_Whitespace

class COLLISION_URDF: 

    def __init__(self,origin,geometry):

        self.origin = origin

        self.geometry = geometry
 
        self.depth = 2

    def Save(self,f):

        self.Save_Start_Tag(f)

        self.origin.Save(f)

        self.geometry.Save(f)

        self.Save_End_Tag(f)

# ------------------ Private methods ------------------

    def Save_End_Tag(self,f):

        Save_Whitespace(self.depth,f)

        f.write('</collision>\n')

    def Save_Start_Tag(self,f):

        Save_Whitespace(self.depth,f)

        f.write('<collision>\n')

================
File: pyrosim/commonFunctions.py
================
def Save_Whitespace(depth,f):

    for d in range(0,depth):

        f.write('    ')

================
File: pyrosim/constants.py
================
SENSOR_NEURON = 0
MOTOR_NEURON  = 1
HIDDEN_NEURON = 2

================
File: pyrosim/geometrysdf.py
================
from pyrosim.commonFunctions import Save_Whitespace

class GEOMETRY_SDF: 

    def __init__(self,size):

        self.depth   = 4

        self.string1 = '<geometry>'

        sizeString = str(size[0]) + " " + str(size[1]) + " " + str(size[2])

        self.string2 = '   <box>'

        self.string3 = '      <size>' + sizeString + '</size>'

        self.string4 = '   </box>'

        self.string5 = '</geometry>'

    def Save(self,f):

        Save_Whitespace(self.depth,f)

        f.write( self.string1 + '\n' )

        Save_Whitespace(self.depth,f)

        f.write( self.string2 + '\n' )

        Save_Whitespace(self.depth,f)

        f.write( self.string3 + '\n' )

        Save_Whitespace(self.depth,f)

        f.write( self.string4 + '\n' )

        Save_Whitespace(self.depth,f)

        f.write( self.string5 + '\n' )

================
File: pyrosim/geometryurdf.py
================
from pyrosim.commonFunctions import Save_Whitespace

class GEOMETRY_URDF: 

    def __init__(self,size):

        self.depth   = 3

        self.string1 = '<geometry>'

        sizeString = str(size[0]) + " " + str(size[1]) + " " + str(size[2])

        self.string2 = '    <box size="' + sizeString + '" />'

        self.string3 = '</geometry>'

    def Save(self,f):

        Save_Whitespace(self.depth,f)

        f.write( self.string1 + '\n' )

        Save_Whitespace(self.depth,f)

        f.write( self.string2 + '\n' )

        Save_Whitespace(self.depth,f)

        f.write( self.string3 + '\n' )

================
File: pyrosim/inertialsdf.py
================
from pyrosim.masssdf         import MASS_SDF

from pyrosim.inertiasdf      import INERTIA_SDF

from pyrosim.commonFunctions import Save_Whitespace

class INERTIAL_SDF:

    def __init__(self):

        self.depth = 3

        self.mass = MASS_SDF()

        self.inertia = INERTIA_SDF()

    def Save(self,f):

        self.Save_Start_Tag(f)

        self.Save_Elements(f)

        self.Save_End_Tag(f)

# --------------------------- Private ------------------

    def Save_Start_Tag(self,f):

        Save_Whitespace(self.depth,f)

        f.write('<inertial>\n')

    def Save_Elements(self,f):

        self.mass.Save(f)

        self.inertia.Save(f)

    def Save_End_Tag(self,f):

        Save_Whitespace(self.depth,f)

        f.write('</inertial>\n')

================
File: pyrosim/inertialurdf.py
================
from pyrosim.massurdf    import MASS_URDF

from pyrosim.inertiaurdf import INERTIA_URDF

from pyrosim.commonFunctions import Save_Whitespace

class INERTIAL_URDF:

    def __init__(self,origin):

        self.depth = 2

        self.origin = origin

        self.mass = MASS_URDF()

        self.inertia = INERTIA_URDF()

    def Save(self,f):

        self.Save_Start_Tag(f)

        self.Save_Elements(f)

        self.Save_End_Tag(f)

# --------------------------- Private ------------------

    def Save_Start_Tag(self,f):

        Save_Whitespace(self.depth,f)

        f.write('<inertial>\n')

    def Save_Elements(self,f):

        self.origin.Save(f)

        self.mass.Save(f)

        self.inertia.Save(f)

    def Save_End_Tag(self,f):

        Save_Whitespace(self.depth,f)

        f.write('</inertial>\n')

================
File: pyrosim/inertiasdf.py
================
from pyrosim.commonFunctions import Save_Whitespace


class INERTIA_SDF: 

    def __init__(self):

        self.depth = 4 

        self.string1 = '<inertia>'

        self.string2 = '    <ixx>0.083</ixx>'

        self.string3 = '    <ixy>0.0</ixy>'

        self.string4 = '    <ixz>0.0</ixz>'

        self.string5 = '    <iyy>0.083</iyy>'

        self.string6 = '    <iyz>0.0</iyz>'

        self.string7 = '    <izz>0.083</izz>'

        self.string8 = '</inertia>'


    def Save(self,f):

        Save_Whitespace(self.depth,f)
        f.write(self.string1 + '\n')

        Save_Whitespace(self.depth,f)
        f.write(self.string2 + '\n')

        Save_Whitespace(self.depth,f)
        f.write(self.string3 + '\n')

        Save_Whitespace(self.depth,f)
        f.write(self.string4 + '\n')

        Save_Whitespace(self.depth,f)
        f.write(self.string5 + '\n')

        Save_Whitespace(self.depth,f)
        f.write(self.string6 + '\n')

        Save_Whitespace(self.depth,f)
        f.write(self.string7 + '\n')

        Save_Whitespace(self.depth,f)
        f.write(self.string8 + '\n')

================
File: pyrosim/inertiaurdf.py
================
from pyrosim.commonFunctions import Save_Whitespace


class INERTIA_URDF: 

    def __init__(self):

        self.depth = 3 

        self.string1 = '<inertia ixx="100" ixy="0" ixz="0" iyy="100" iyz="0" izz="100" />'

    def Save(self,f):

        Save_Whitespace(self.depth,f)
        f.write(self.string1 + '\n')

================
File: pyrosim/joint.py
================
from pyrosim.commonFunctions import Save_Whitespace

class JOINT: 

    def __init__(self,name,parent,child,type,position):

        self.name = name

        self.parent = parent

        self.child  = child

        self.type   = type

        self.position = position

        self.depth = 1

    def Save(self,f):

        Save_Whitespace(self.depth,f)
        f.write('<joint name="' + self.name + '" type="' + self.type + '">' + '\n')

        Save_Whitespace(self.depth,f)
        f.write('   <parent link="' + self.parent + '"/>' + '\n')

        Save_Whitespace(self.depth,f)
        f.write('   <child  link="' + self.child  + '"/>' + '\n')

        Save_Whitespace(self.depth,f)
        originString = str(self.position[0]) + " " + str(self.position[1]) + " " + str(self.position[2])
        f.write('   <origin rpy="0 0 0" xyz="' + originString + '" />\n')

        Save_Whitespace(self.depth,f)
        f.write('   <axis xyz="0 1 0"/>\n')

        Save_Whitespace(self.depth,f)
        f.write('   <limit effort="0.0" lower="-3.14159" upper="3.14159" velocity="0.0"/>\n')

        Save_Whitespace(self.depth,f)
        f.write('</joint>' + '\n')

================
File: pyrosim/linksdf.py
================
from pyrosim.inertialsdf     import INERTIAL_SDF

from pyrosim.geometrysdf     import GEOMETRY_SDF

from pyrosim.collisionsdf    import COLLISION_SDF

from pyrosim.visualsdf       import VISUAL_SDF

from pyrosim.commonFunctions import Save_Whitespace

class LINK_SDF:

    def __init__(self,name,pos,size):

        self.name = name

        self.depth = 2

        self.inertial  = INERTIAL_SDF()

        self.geometry = GEOMETRY_SDF(size)

        self.collision = COLLISION_SDF(self.geometry)

        self.visual    = VISUAL_SDF(self.geometry)

    def Save(self,f):

        self.Save_Start_Tag(f)

        self.inertial.Save(f)

        self.collision.Save(f)

        self.visual.Save(f)

        self.Save_End_Tag(f)

# ------------------- Private methods -----------------

    def Save_End_Tag(self,f):

        Save_Whitespace(self.depth,f)

        f.write('</link>\n')

    def Save_Start_Tag(self,f):

        Save_Whitespace(self.depth,f)

        f.write('<link name="' + self.name + '">\n')

================
File: pyrosim/linkurdf.py
================
from pyrosim.originurdf      import ORIGIN_URDF

from pyrosim.geometryurdf    import GEOMETRY_URDF

from pyrosim.inertialurdf    import INERTIAL_URDF

from pyrosim.visualurdf      import VISUAL_URDF

from pyrosim.collisionurdf   import COLLISION_URDF

from pyrosim.commonFunctions import Save_Whitespace

class LINK_URDF:

    def __init__(self,name,pos,size):

        self.name = name

        self.depth = 1

        self.origin   = ORIGIN_URDF(pos)

        self.inertial  = INERTIAL_URDF(self.origin)

        self.geometry = GEOMETRY_URDF(size)

        self.visual    = VISUAL_URDF(self.origin , self.geometry)

        self.collision = COLLISION_URDF(self.origin , self.geometry)

    def Save(self,f):

        self.Save_Start_Tag(f)

        self.inertial.Save(f)

        self.visual.Save(f)

        self.collision.Save(f)

        self.Save_End_Tag(f)

# ------------------- Private methods -----------------

    def Save_End_Tag(self,f):

        Save_Whitespace(self.depth,f)

        f.write('</link>\n')

    def Save_Start_Tag(self,f):

        Save_Whitespace(self.depth,f)

        f.write('<link name="' + self.name + '">\n')

================
File: pyrosim/masssdf.py
================
from pyrosim.commonFunctions import Save_Whitespace


class MASS_SDF: 

    def __init__(self):

        self.string =  '<mass>1.0</mass>'

        self.depth = 4

    def Save(self,f):

        Save_Whitespace(self.depth,f)

        f.write(self.string + '\n' )

================
File: pyrosim/massurdf.py
================
from pyrosim.commonFunctions import Save_Whitespace

class MASS_URDF: 

    def __init__(self):

        self.string =  '<mass value="1" />'

        self.depth = 3

    def Save(self,f):

        Save_Whitespace(self.depth,f)

        f.write(self.string + '\n' )

================
File: pyrosim/material.py
================
from pyrosim.commonFunctions import Save_Whitespace

class MATERIAL: 

    def __init__(self):

        self.depth  = 3

        self.string1 = '<material name="Cyan">'

        self.string2 = '    <color rgba="0 1.0 1.0 1.0"/>'

        self.string3 = '</material>'

    def Save(self,f):

        Save_Whitespace(self.depth,f)

        f.write( self.string1 + '\n' )

        Save_Whitespace(self.depth,f)

        f.write( self.string2 + '\n' )

        Save_Whitespace(self.depth,f)

        f.write( self.string3 + '\n' )

================
File: pyrosim/model.py
================
import pyrosim.commonFunctions as commonFunctions

class MODEL:

    def __init__(self,modelName,pos):

        self.depth = 1

        self.pos = pos

        self.modelName = modelName

    def Save_Start_Tag(self,f):

        commonFunctions.Save_Whitespace(self.depth,f)

        f.write('<model name="' + self.modelName + '">\n')

        commonFunctions.Save_Whitespace(self.depth,f)

        pose = str(self.pos[0]) + ' ' + str(self.pos[1]) + ' ' + str(self.pos[2])

        f.write('    <pose>' + pose + ' 0 0 0 </pose>\n')

    def Save_End_Tag(self,f):

        commonFunctions.Save_Whitespace(self.depth,f)

        f.write("</model>\n")

================
File: pyrosim/neuralNetwork.py
================
from pyrosim.neuron  import NEURON

from pyrosim.synapse import SYNAPSE

class NEURAL_NETWORK: 

    def __init__(self,nndfFileName):

        self.neurons = {}

        self.synapses = {}

        f = open(nndfFileName,"r")

        for line in f.readlines():

            self.Digest(line)

        f.close()

    def Print(self):

        self.Print_Sensor_Neuron_Values()

        self.Print_Hidden_Neuron_Values()

        self.Print_Motor_Neuron_Values()

        print("")

    def Update(self):
        for neuron_name in self.neurons:
            if self.neurons[neuron_name].Is_Sensor_Neuron():
                self.neurons[neuron_name].Update_Sensor_Neuron()
            else:
                self.neurons[neuron_name].Update_Hidden_Or_Motor_Neuron(self.neurons, self.synapses)

    def Get_Neuron_Names(self):
        return self.neurons.keys()
    
    def Is_Motor_Neuron(self, neuron_name):
        return self.neurons[neuron_name].Is_Motor_Neuron()
    
    def Get_Motor_Neurons_Joint(self, neuron_name):
        return self.neurons[neuron_name].Get_Joint_Name()
    
    def Get_Value_Of(self, neuron_name):
        return self.neurons[neuron_name].Get_Value()

# ---------------- Private methods --------------------------------------

    def Add_Neuron_According_To(self,line):

        neuron = NEURON(line)

        self.neurons[ neuron.Get_Name() ] = neuron

    def Add_Synapse_According_To(self,line):

        synapse = SYNAPSE(line)

        sourceNeuronName = synapse.Get_Source_Neuron_Name()

        targetNeuronName = synapse.Get_Target_Neuron_Name()

        self.synapses[sourceNeuronName , targetNeuronName] = synapse

    def Digest(self,line):

        if self.Line_Contains_Neuron_Definition(line):

            self.Add_Neuron_According_To(line)

        if self.Line_Contains_Synapse_Definition(line):

            self.Add_Synapse_According_To(line)

    def Line_Contains_Neuron_Definition(self,line):

        return "neuron" in line

    def Line_Contains_Synapse_Definition(self,line):

        return "synapse" in line

    def Print_Sensor_Neuron_Values(self):

        print("sensor neuron values: " , end = "" )

        for neuronName in sorted(self.neurons):

            if self.neurons[neuronName].Is_Sensor_Neuron():

                self.neurons[neuronName].Print()

        print("")

    def Print_Hidden_Neuron_Values(self):

        print("hidden neuron values: " , end = "" )

        for neuronName in sorted(self.neurons):

            if self.neurons[neuronName].Is_Hidden_Neuron():

                self.neurons[neuronName].Print()

        print("")

    def Print_Motor_Neuron_Values(self):

        print("motor neuron values: " , end = "" )

        for neuronName in sorted(self.neurons):

            if self.neurons[neuronName].Is_Motor_Neuron():

                self.neurons[neuronName].Print()

        print("")

================
File: pyrosim/neuron.py
================
import math

import pybullet

import pyrosim.pyrosim as pyrosim

import pyrosim.constants as c

class NEURON: 

    def __init__(self,line):

        self.Determine_Name(line)

        self.Determine_Type(line)

        self.Search_For_Link_Name(line)

        self.Search_For_Joint_Name(line)

        self.Set_Value(0.0)

    def Add_To_Value( self, value ):

        self.Set_Value( self.Get_Value() + value )

    def Get_Joint_Name(self):

        return self.jointName

    def Get_Link_Name(self):

        return self.linkName

    def Get_Name(self):

        return self.name

    def Get_Value(self):

        return self.value

    def Is_Sensor_Neuron(self):

        return self.type == c.SENSOR_NEURON

    def Is_Hidden_Neuron(self):

        return self.type == c.HIDDEN_NEURON

    def Is_Motor_Neuron(self):

        return self.type == c.MOTOR_NEURON
    
    def Update_Sensor_Neuron(self):
        self.Set_Value(pyrosim.Get_Touch_Sensor_Value_For_Link(self.Get_Link_Name()))

    def Update_Hidden_Or_Motor_Neuron(self, neurons, synapses):
        self.Set_Value(0.0)
        for key in synapses:
            if key[1] == self.Get_Name():
                presynaptic_value = neurons[key[0]].Get_Value()
                weight = synapses[key].Get_Weight()
                self.Allow_Presynaptic_Neuron_To_Influence_Me(weight, presynaptic_value)

        self.Threshold()

    def Allow_Presynaptic_Neuron_To_Influence_Me(self, synapse, neuron):
        result = synapse * neuron
        self.Add_To_Value(result)

    def Print(self):

        # self.Print_Name()

        # self.Print_Type()

        self.Print_Value()

        # print("")

    def Set_Value(self,value):

        self.value = value

# -------------------------- Private methods -------------------------

    def Determine_Name(self,line):

        if "name" in line:

            splitLine = line.split('"')

            self.name = splitLine[1]

    def Determine_Type(self,line):

        if "sensor" in line:

            self.type = c.SENSOR_NEURON

        elif "motor" in line:

            self.type = c.MOTOR_NEURON

        else:

            self.type = c.HIDDEN_NEURON

    def Print_Name(self):

       print(self.name)

    def Print_Type(self):

       print(self.type)

    def Print_Value(self):

       print(self.value , " " , end="" )

    def Search_For_Joint_Name(self,line):

        if "jointName" in line:

            splitLine = line.split('"')

            self.jointName = splitLine[5]

    def Search_For_Link_Name(self,line):

        if "linkName" in line:

            splitLine = line.split('"')

            self.linkName = splitLine[5]

    def Threshold(self):

        self.value = math.tanh(self.value)

================
File: pyrosim/nndf.py
================
class NNDF: 

    def __init__(self):

        pass

    def Save_Start_Tag(self,f):

        f.write('<neuralNetwork>\n')

    def Save_End_Tag(self,f):

        f.write('</neuralNetwork>')

================
File: pyrosim/originurdf.py
================
from pyrosim.commonFunctions import Save_Whitespace

class ORIGIN_URDF: 

    def __init__(self,pos):

        self.depth  = 3

        posString = str(pos[0]) + " " + str(pos[1]) + " " + str(pos[2])

        self.string = '<origin xyz="' + posString + '" rpy="0 0 0"/>'

    def Save(self,f):

        Save_Whitespace(self.depth,f)

        f.write( self.string + '\n' )

================
File: pyrosim/pyrosim.py
================
import pybullet as p

from pyrosim.nndf import NNDF

from pyrosim.linksdf  import LINK_SDF

from pyrosim.linkurdf import LINK_URDF

from pyrosim.model import MODEL

from pyrosim.sdf   import SDF

from pyrosim.urdf  import URDF

from pyrosim.joint import JOINT

SDF_FILETYPE  = 0

URDF_FILETYPE = 1

NNDF_FILETYPE   = 2

# global availableLinkIndex

# global linkNamesToIndices

def End():

    if filetype == SDF_FILETYPE:

        sdf.Save_End_Tag(f)

    elif filetype == NNDF_FILETYPE:

        nndf.Save_End_Tag(f)
    else:
        urdf.Save_End_Tag(f)

    f.close()

def End_Model():

    model.Save_End_Tag(f)

def Get_Touch_Sensor_Value_For_Link(linkName):
    touchValue = -1.0
    desiredLinkIndex = linkNamesToIndices[linkName]
    pts = p.getContactPoints()
    if pts is None:
        pts = []
    for pt in pts:
        if pt[4] == desiredLinkIndex:
            touchValue = 1.0
    return touchValue

def Prepare_Link_Dictionary(bodyID):

    global linkNamesToIndices

    linkNamesToIndices = {}

    for jointIndex in range( 0 , p.getNumJoints(bodyID) ):

        jointInfo = p.getJointInfo( bodyID , jointIndex )

        jointName = jointInfo[1]

        jointName = jointName.decode("utf-8")

        jointName = jointName.split("_")

        linkName = jointName[1]

        linkNamesToIndices[linkName] = jointIndex

        if jointIndex==0:

           rootLinkName = jointName[0]

           linkNamesToIndices[rootLinkName] = -1 

def Prepare_Joint_Dictionary(bodyID):

    global jointNamesToIndices

    jointNamesToIndices = {}

    for jointIndex in range( 0 , p.getNumJoints(bodyID) ):

        jointInfo = p.getJointInfo( bodyID , jointIndex )

        jointName = jointInfo[1].decode('UTF-8')

        jointNamesToIndices[jointName] = jointIndex

def Prepare_To_Simulate(bodyID):

    Prepare_Link_Dictionary(bodyID)

    Prepare_Joint_Dictionary(bodyID)

def Send_Cube(name="default",pos=[0,0,0],size=[1,1,1]):

    global availableLinkIndex

    global links

    if filetype == SDF_FILETYPE:

        Start_Model(name,pos)

        link = LINK_SDF(name,pos,size)

        links.append(link)
    else:
        link = LINK_URDF(name,pos,size)

        links.append(link)

    link.Save(f)

    if filetype == SDF_FILETYPE:

        End_Model()

    linkNamesToIndices[name] = availableLinkIndex

    availableLinkIndex = availableLinkIndex + 1

def Send_Joint(name,parent,child,type,position):

    joint = JOINT(name,parent,child,type,position)

    joint.Save(f)

def Send_Motor_Neuron(name,jointName):

    f.write('    <neuron name = "' + str(name) + '" type = "motor"  jointName = "' + jointName + '" />\n')

def Send_Sensor_Neuron(name,linkName):

    f.write('    <neuron name = "' + str(name) + '" type = "sensor" linkName = "' + linkName + '" />\n')

def Send_Synapse( sourceNeuronName , targetNeuronName , weight ):

    f.write('    <synapse sourceNeuronName = "' + str(sourceNeuronName) + '" targetNeuronName = "' + str(targetNeuronName) + '" weight = "' + str(weight) + '" />\n')

 
def Set_Motor_For_Joint(bodyIndex,jointName,controlMode,targetPosition,maxForce):

    p.setJointMotorControl2(

        bodyIndex      = bodyIndex,

        jointIndex     = jointNamesToIndices[jointName],

        controlMode    = controlMode,

        targetPosition = targetPosition,

        force          = maxForce)

def Start_NeuralNetwork(filename):

    global filetype

    filetype = NNDF_FILETYPE

    global f

    f = open(filename,"w")

    global nndf

    nndf = NNDF()

    nndf.Save_Start_Tag(f)

def Start_SDF(filename):

    global availableLinkIndex

    availableLinkIndex = -1

    global linkNamesToIndices

    linkNamesToIndices = {}

    global filetype

    filetype = SDF_FILETYPE

    global f
 
    f = open(filename,"w")

    global sdf

    sdf = SDF()

    sdf.Save_Start_Tag(f)

    global links

    links = []

def Start_URDF(filename):

    global availableLinkIndex

    availableLinkIndex = -1

    global linkNamesToIndices

    linkNamesToIndices = {}

    global filetype

    filetype = URDF_FILETYPE

    global f

    f = open(filename,"w")

    global urdf 

    urdf = URDF()

    urdf.Save_Start_Tag(f)

    global links

    links = []

def Start_Model(modelName,pos):

    global model 

    model = MODEL(modelName,pos)

    model.Save_Start_Tag(f)

================
File: pyrosim/README.md
================
# ludobots
Simplifying the training of neural network controlled robots in pybullet.

# Getting started

Install pybullet:

pip install pybullet

================
File: pyrosim/robot.py
================
class ROBOT:

    def __init__(self):

        pass

    def Save_Start_Tag(self,f):

        f.write('<robot name="robot">\n')

    def Save_End_Tag(self,f):

        f.write("</robot>")

================
File: pyrosim/sdf.py
================
class SDF:

    def __init__(self):

        self.depth = 0

    def Save_Start_Tag(self,f):

        f.write('<sdf>\n')

    def Save_End_Tag(self,f):

        f.write("</sdf>")

================
File: pyrosim/synapse.py
================
import math

import pyrosim.pyrosim as pyrosim

import pyrosim.constants as c

class SYNAPSE: 

    def __init__(self,line):

        self.Determine_Source_Neuron_Name(line)

        self.Determine_Target_Neuron_Name(line)

        self.Determine_Weight(line)

    def Get_Source_Neuron_Name(self):

        return self.sourceNeuronName

    def Get_Target_Neuron_Name(self):

        return self.targetNeuronName

    def Get_Weight(self):

        return self.weight

# -------------------------- Private methods -------------------------

    def Determine_Source_Neuron_Name(self,line):

        if "sourceNeuronName" in line:

            splitLine = line.split('"')

            self.sourceNeuronName = splitLine[1]

    def Determine_Target_Neuron_Name(self,line):

        if "targetNeuronName" in line:

            splitLine = line.split('"')

            self.targetNeuronName = splitLine[3]

    def Determine_Weight(self,line):

        if "weight" in line:

            splitLine = line.split('"')

            self.weight = float( splitLine[5] )

================
File: pyrosim/urdf.py
================
class URDF:

    def __init__(self):

        self.depth = 0

    def Save_Start_Tag(self,f):

        f.write('<robot name = "robot">\n')

    def Save_End_Tag(self,f):

        f.write("</robot>")

================
File: pyrosim/visualsdf.py
================
from pyrosim.commonFunctions import Save_Whitespace

class VISUAL_SDF: 

    def __init__(self,geometry):

        self.geometry = geometry 

        self.depth = 3

    def Save(self,f):

        self.Save_Start_Tag(f)

        self.Save_Elements(f)

        self.Save_End_Tag(f)

# ------------------ Private methods ------------------

    def Save_Start_Tag(self,f):

        Save_Whitespace(self.depth,f)

        f.write('<visual>\n')

    def Save_Elements(self,f):

        self.geometry.Save(f)

    def Save_End_Tag(self,f):

        Save_Whitespace(self.depth,f)

        f.write('</visual>\n')

================
File: pyrosim/visualurdf.py
================
from pyrosim.material import MATERIAL

from pyrosim.commonFunctions import Save_Whitespace

class VISUAL_URDF: 

    def __init__(self,origin,geometry):

        self.origin = origin

        self.geometry = geometry 

        self.material = MATERIAL()

        self.depth = 2

    def Save(self,f):

        self.Save_Start_Tag(f)

        self.Save_Elements(f)

        self.Save_End_Tag(f)

# ------------------ Private methods ------------------

    def Save_Start_Tag(self,f):

        Save_Whitespace(self.depth,f)

        f.write('<visual>\n')

    def Save_Elements(self,f):

        self.origin.Save(f)

        self.geometry.Save(f)

        self.material.Save(f)

    def Save_End_Tag(self,f):

        Save_Whitespace(self.depth,f)

        f.write('</visual>\n')

================
File: scripts/analyze.py
================
"""
analyze.py
Script for loading and plotting the sensor or motor data generated by the simulation,
helping to visualize results or debug robot behavior.
"""

import numpy as np
import matplotlib.pyplot as plt


def main():
    """
    Main function to load sensor values and plot them.
    """
    # back_leg_vals = np.load("data/backLegSensorValues.npy")
    # front_leg_vals = np.load("data/frontLegSensorValues.npy")
    target_angles_bl = np.load("data/sin_values_bl.npy")
    target_angles_fl = np.load("data/sin_values_fl.npy")

    plt.plot(target_angles_bl)
    plt.plot(target_angles_fl)
    # plt.plot(back_leg_vals, label="Back Leg", linewidth=3)
    # plt.plot(front_leg_vals, label="Front Leg")

    plt.legend()
    plt.show()


if __name__ == "__main__":
    main()

================
File: scripts/constants.py
================
"""
constants.py
Holds global constants such as the number of simulation steps, motor frequencies, amplitudes,
and other physical constants (gravity, max force, etc.).
"""

import numpy as np

STEPS = 4000

NUMBER_OF_GENERATIONS = 40

AMPLITUDE_BL = np.pi/3
FREQUENCY_BL = 10
PHASE_OFFSET_BL = 0

AMPLITUDE_FL = np.pi/4
FREQUENCY_FL = 10
PHASE_OFFSET_FL = np.pi

GRAV_X = 0
GRAV_Y = 0
GRAV_Z = -9.8

MAX_FORCE = 20

SLEEP_TIME = 0.005

================
File: scripts/generate.py
================
"""
generate.py
Contains methods for programmatically generating SDF and URDF files for the robot(s) and environment.
"""

from pyrosim import pyrosim
import random
import os


def create_world():
    """
    Create an SDF file named 'world.sdf' containing a single cube.
    """
    pyrosim.Start_SDF("data/world.sdf")
    pyrosim.Send_Cube(name="Box", pos=[-4, 4, 0.5], size=[1, 1, 1])
    pyrosim.End()


def create_robot():
    """
    Create a URDF file named 'body.urdf' containing a multi-link robot.
    """
    pyrosim.Start_URDF("data/body.urdf")

    pyrosim.Send_Cube(name="Link0", pos=[0, 0, 0.5], size=[1, 1, 1])
    pyrosim.Send_Joint(
        name="Link0_Link1",
        parent="Link0",
        child="Link1",
        type="revolute",
        position=[0.0, 0.0, 1.0],
    )
    pyrosim.Send_Cube(name="Link1", pos=[0, 0, 0.5], size=[1, 1, 1])

    pyrosim.Send_Joint(
        name="Link1_Link2",
        parent="Link1",
        child="Link2",
        type="revolute",
        position=[0.0, 0.0, 1.0],
    )
    pyrosim.Send_Cube(name="Link2", pos=[0, 0, 0.5], size=[1, 1, 1])

    pyrosim.Send_Joint(
        name="Link2_Link3",
        parent="Link2",
        child="Link3",
        type="revolute",
        position=[0.0, 0.5, 0.5],
    )
    pyrosim.Send_Cube(name="Link3", pos=[0, 0.5, 0], size=[1, 1, 1])

    pyrosim.Send_Joint(
        name="Link3_Link4",
        parent="Link3",
        child="Link4",
        type="revolute",
        position=[0.0, 1.0, 0.0],
    )
    pyrosim.Send_Cube(name="Link4", pos=[0, 0.5, 0], size=[1, 1, 1])

    # Typo fix: 'osition' -> 'position'
    pyrosim.Send_Joint(
        name="Link4_Link5",
        parent="Link4",
        child="Link5",
        type="revolute",
        position=[0.0, 0.5, -0.5],
    )
    pyrosim.Send_Cube(name="Link5", pos=[0, 0, -0.5], size=[1, 1, 1])

    pyrosim.Send_Joint(
        name="Link5_Link6",
        parent="Link5",
        child="Link6",
        type="revolute",
        position=[0.0, 0.0, -1.0],
    )
    pyrosim.Send_Cube(name="Link6", pos=[0, 0, -0.5], size=[1, 1, 1])

    pyrosim.End()


def create_three_link_two_joint():
    """
    Creates a 3-link robot with two revolute joints.
    """
    pyrosim.Start_URDF("data/three_link.urdf")

    pyrosim.Send_Cube(
        name="Torso",
        pos=[1.5, 0.0, 1.5],
        size=[1, 1, 1]
    )

    # First joint: Torso -> BackLeg
    pyrosim.Send_Joint(
        name="Torso_BackLeg",
        parent="Torso",
        child="BackLeg",
        type="revolute",
        position=[1.0, 0.0, 0.5],
    )
    pyrosim.Send_Cube(
        name="BackLeg",
        pos=[-0.5, 0.0, 0],
        size=[1, 1, 1]
    )

    # Second joint: Torso -> FrontLeg
    pyrosim.Send_Joint(
        name="Torso_FrontLeg",
        parent="Torso",
        child="FrontLeg",
        type="revolute",
        position=[2.0, 0.0, 0.5],
    )
    pyrosim.Send_Cube(
        name="FrontLeg",
        pos=[0.5, 0.0, 0],
        size=[1, 1, 1]
    )

    pyrosim.End()


def Generate_Body():
    """
    Creates a 3-link robot with two revolute joints.
    """
    pyrosim.Start_URDF("data/body.urdf")

    pyrosim.Send_Cube(
        name="Torso",
        pos=[1.5, 0.0, 1.5],
        size=[1, 1, 1]
    )

    # First joint: Torso -> BackLeg
    pyrosim.Send_Joint(
        name="Torso_BackLeg",
        parent="Torso",
        child="BackLeg",
        type="revolute",
        position=[1.0, 0.0, 0.5],
    )
    pyrosim.Send_Cube(
        name="BackLeg",
        pos=[-0.5, 0.0, 0],
        size=[1, 1, 1]
    )

    # Second joint: Torso -> FrontLeg
    pyrosim.Send_Joint(
        name="Torso_FrontLeg",
        parent="Torso",
        child="FrontLeg",
        type="revolute",
        position=[2.0, 0.0, 0.5],
    )
    pyrosim.Send_Cube(
        name="FrontLeg",
        pos=[0.5, 0.0, 0],
        size=[1, 1, 1]
    )

    pyrosim.End()


def Generate_Brain():
    """
    Creates a brain.
    """
    pyrosim.Start_NeuralNetwork("data/brain.nndf")
    pyrosim.Send_Sensor_Neuron(name=0, linkName="Torso")
    pyrosim.Send_Sensor_Neuron(name=1, linkName="BackLeg")
    pyrosim.Send_Sensor_Neuron(name=2, linkName="FrontLeg")
    pyrosim.Send_Motor_Neuron(name=3, jointName="Torso_BackLeg")
    pyrosim.Send_Motor_Neuron(name=4, jointName="Torso_FrontLeg")

    for i in range(3):
        for j in range(3,5):
            pyrosim.Send_Synapse(sourceNeuronName=i, targetNeuronName=j, weight=2*random.random()-1)
    pyrosim.End()


def main():
    """
    Main function to create both the robot
    """
    create_world()
    Generate_Body()
    Generate_Brain()


if __name__ == "__main__":
    if not os.path.exists("data"):
        os.makedirs("data")
    main()

================
File: scripts/hillclimber.py
================
"""
motor.py
Implements increasingly efficient, but increasingly complex 
search methods to find good synaptic weights for a given 
desired behavior.
"""

from solution import SOLUTION
import constants as c
import copy

class HILL_CLIMBER:
    def __init__(self):
        self.parent = SOLUTION()

    def Evolve(self):
        self.parent.Evaluate('DIRECT')
        for _ in range(c.NUMBER_OF_GENERATIONS):
            self.Evolve_For_One_Generation()

    def Evolve_For_One_Generation(self):
        self.Spawn()
        self.Mutate()
        self.child.Evaluate('DIRECT')
        self.Select()

    def Spawn(self):
        self.child = copy.deepcopy(self.parent)

    def Mutate(self):
        self.child.Mutate()

    def Select(self):
        if self.parent.fitness > self.child.fitness:
            self.parent = self.child
    
    def Print(self):
        print(f'Parent: {self.parent.fitness} Child: {self.child.fitness}')

    def Show_Best(self):
        self.parent.Evaluate('GUI')

================
File: scripts/motor.py
================
"""
motor.py
Defines the MOTOR class, which controls a single revolute joint in the robot.
It stores parameters for motion (amplitude, frequency, etc.) and commands the joint each timestep.
"""

import constants as c
import numpy as np
import pybullet as p
from pyrosim import pyrosim

class MOTOR:
    def __init__(self, joint_name):
        self.joint_name = joint_name

    def Set_Value(self, desiredAngle, robot_id):
        self.robot_id = robot_id
        target_position = desiredAngle

        pyrosim.Set_Motor_For_Joint(
                bodyIndex=self.robot_id,
                jointName=self.joint_name,
                controlMode=p.POSITION_CONTROL,
                targetPosition=target_position,
                maxForce=c.MAX_FORCE,
            )

================
File: scripts/robot.py
================
"""
robot.py
Defines the ROBOT class, which aggregates all the robot's sensors and motors.
It loads the robot's URDF, prepares the sensors and motors, and coordinates sensing/acting.
"""

import pybullet as p
from pyrosim import pyrosim
from sensor import SENSOR
from motor import MOTOR
from pyrosim.neuralNetwork import NEURAL_NETWORK

class ROBOT:
    def __init__(self):
        self.robot_id = p.loadURDF("data/body.urdf")
        pyrosim.Prepare_To_Simulate(self.robot_id)
        self.nn = NEURAL_NETWORK("data/brain.nndf")
        self.Prepare_To_Sense()
        self.Prepare_To_Act()

    def Prepare_To_Sense(self):
        self.sensors = {}
        for link_name in pyrosim.linkNamesToIndices:
            self.sensors[link_name] = SENSOR(link_name)

    def Sense(self, t):
        for _, sensor_obj in self.sensors.items():
            sensor_obj.Get_Value(t)

    def Prepare_To_Act(self):
        self.motors = {}
        for joint_name in pyrosim.jointNamesToIndices:
            self.motors[joint_name] = MOTOR(joint_name)

    def Act(self, t):
        for neuron_name in self.nn.Get_Neuron_Names():
            if self.nn.Is_Motor_Neuron(neuron_name):
                jointName = self.nn.Get_Motor_Neurons_Joint(neuron_name)
                desiredAngle = self.nn.Get_Value_Of(neuron_name)
                self.motors[jointName].Set_Value(desiredAngle, self.robot_id)

    def Think(self):
        self.nn.Update()

    def Get_Fitness(self):
        self.stateOfLinkZero = p.getLinkState(self.robot_id, 0)
        self.positionOfLinkZero = self.stateOfLinkZero[0]
        self.xCoordinateOfLinkZero = self.positionOfLinkZero[0]
        with open('data/fitness.txt', 'w') as f:
            f.write(str(self.xCoordinateOfLinkZero))
            f.close()

================
File: scripts/search.py
================
"""
search.py
"""

from hillclimber import HILL_CLIMBER


def main():
    hc = HILL_CLIMBER()
    hc.Evolve()
    hc.Show_Best()

if __name__ == '__main__':
    main()

================
File: scripts/sensor.py
================
"""
sensor.py
Defines the SENSOR class, which measures touch sensor values for a single link.
Stores a time-series of sensor readings for each simulation timestep.
"""

import constants as c
import numpy as np
from pyrosim import pyrosim

class SENSOR:
    """
    An object that allows the robot to know if it is in contact wiht something
    """
    def __init__(self, link_name):
        self.link_name = link_name
        self.values = np.zeros(c.STEPS)

    def Get_Value(self, t):
        """
        Gets the value of the sensor and stores it in a dictionary
        """
        self.values[t] = pyrosim.Get_Touch_Sensor_Value_For_Link(self.link_name)

    def Save_Values(self):
        np.save(f'data/{self.link_name}_sensor_values.npy', self.values)

================
File: scripts/simulate.py
================
"""
simulate.py
Entry point for running the simulation.
Creates an instance of SIMULATION and calls its Run() method.
"""

from simulation import SIMULATION
import sys

def main():
    """
    Creates and runs the simulation
    """
    directOrGUI = sys.argv[1]
    simulation = SIMULATION(directOrGUI)
    simulation.Run()
    simulation.Get_Fitness()

if __name__ == '__main__':
    main()

================
File: scripts/simulation.py
================
"""
simulation.py
Defines the SIMULATION class, which configures PyBullet, loads the world and robot,
runs the simulation loop, and orchestrates sensing and action each timestep.
"""

import constants as c
import pybullet as p
import pybullet_data
import numpy as np
import time

from world import WORLD
from robot import ROBOT

class SIMULATION:
    def __init__(self, directOrGUI):
        if directOrGUI == 'GUI':
            self.physics_client = p.connect(p.GUI)
        else:
            self.physics_client = p.connect(p.DIRECT)
        p.configureDebugVisualizer(p.COV_ENABLE_GUI, 0)
        p.setAdditionalSearchPath(pybullet_data.getDataPath())
        p.setGravity(c.GRAV_X, c.GRAV_Y, c.GRAV_Z)

        self.world = WORLD()
        self.robot = ROBOT()

    def __del__(self):
        p.disconnect()

    def Run(self):
        for i in range(c.STEPS):
            p.stepSimulation()
            self.robot.Sense(i)
            self.robot.Think()
            self.robot.Act(i)
            time.sleep(c.SLEEP_TIME)

    def Get_Fitness(self):
        self.robot.Get_Fitness()

================
File: scripts/solution.py
================
"""
solution.py
"""

import numpy as np
from pyrosim import pyrosim
import os
import random

class SOLUTION:
    def __init__(self):
        self.weights = np.random.rand(3, 2)
        self.weights = self.weights * 2 - 1

    def Evaluate(self, directOrGUI='DIRECT', robot_id=0):
        self.Create_World()
        self.Create_Body()
        self.Create_Brain()
        os.system(f"python scripts/simulate.py {directOrGUI} {robot_id} &>/dev/null ")
        with open('data/fitness.txt', 'r') as f:
            self.fitness = f.read()
            self.fitness = float(self.fitness)
            f.close()

    def Create_World(self):
        if not os.path.exists("data"):
            os.makedirs("data")
        pyrosim.Start_SDF("data/world.sdf")
        pyrosim.Send_Cube(name="Box", pos=[-4, 4, 0.5], size=[1, 1, 1])
        pyrosim.End()

    def Create_Body(self):
        pyrosim.Start_URDF("data/body.urdf")

        pyrosim.Send_Cube(
            name="Torso",
            pos=[1.5, 0.0, 1.5],
            size=[1, 1, 1]
        )

        # First joint: Torso -> BackLeg
        pyrosim.Send_Joint(
            name="Torso_BackLeg",
            parent="Torso",
            child="BackLeg",
            type="revolute",
            position=[1.0, 0.0, 0.5],
        )
        pyrosim.Send_Cube(
            name="BackLeg",
            pos=[-0.5, 0.0, 0],
            size=[1, 1, 1]
        )

        # Second joint: Torso -> FrontLeg
        pyrosim.Send_Joint(
            name="Torso_FrontLeg",
            parent="Torso",
            child="FrontLeg",
            type="revolute",
            position=[2.0, 0.0, 0.5],
        )
        pyrosim.Send_Cube(
            name="FrontLeg",
            pos=[0.5, 0.0, 0],
            size=[1, 1, 1]
        )

        pyrosim.End()

    def Create_Brain(self):
        pyrosim.Start_NeuralNetwork("data/brain.nndf")
        pyrosim.Send_Sensor_Neuron(name=0, linkName="Torso")
        pyrosim.Send_Sensor_Neuron(name=1, linkName="BackLeg")
        pyrosim.Send_Sensor_Neuron(name=2, linkName="FrontLeg")
        pyrosim.Send_Motor_Neuron(name=3, jointName="Torso_BackLeg")
        pyrosim.Send_Motor_Neuron(name=4, jointName="Torso_FrontLeg")

        for currentRow in range(3):
            for currentColumn in range(2):
                pyrosim.Send_Synapse(sourceNeuronName=currentRow, 
                                     targetNeuronName=currentColumn+3, 
                                     weight=self.weights[currentRow][currentColumn])
        pyrosim.End()

    def Mutate(self):
        rand_row = random.randint(0, 2)
        rand_col = random.randint(0, 1)
        self.weights[rand_row,rand_col] = random.random() * 2 - 1

================
File: scripts/world.py
================
"""
world.py
Defines the WORLD class, which loads the SDF world and plane into the PyBullet simulation.
"""

import pybullet as p

class WORLD:
    """
    Loads a world and a plane for the simulation
    """
    def __init__(self):
        p.loadSDF("data/world.sdf")
        self.plane_id = p.loadURDF("plane.urdf")

================
File: .gitignore
================
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
#   For a library or package, you might want to ignore these files since the code is
#   intended to run in multiple environments; otherwise, check them in:
# .python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# UV
#   Similar to Pipfile.lock, it is generally recommended to include uv.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#uv.lock

# poetry
#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control
#poetry.lock

# pdm
#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.
#pdm.lock
#   pdm stores project-wide configurations in .pdm.toml, but it is recommended to not include it
#   in version control.
#   https://pdm.fming.dev/latest/usage/project/#working-with-version-control
.pdm.toml
.pdm-python
.pdm-build/

# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/

# PyCharm
#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#  and can be added to the global gitignore or merged into this file.  For a more nuclear
#  option (not recommended) you can uncomment the following to ignore the entire idea folder.
#.idea/

# PyPI configuration file
.pypirc

# MacOS .DS_Store
**/.DS_Store

# Data
data/

================
File: LICENSE
================
MIT License

Copyright (c) 2025 aaron perkel

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: pylintrc
================
[BASIC]

# Good variable names which should always be accepted, separated by a comma
# We have some shorties that are OK. app = application, cnx = connection,
good-names=ok,a,b,c,d,e,f,g,g_,h,i,j,k,m,n,p,q,r,s,t,u,v,x,y,z,app,cnx,fh

# Bad variable names which should always be refused, separated by a comma
bad-names=l,O,I,foo,bar,baz,id

# Regular expression matching correct constant names
const-rgx=(([A-Z_][A-Z0-9_]*)|(__.*__))$

extension-pkg-whitelist=

ignore=

# F0401 Unable to import module
# W0511 TODO
# PyLint's import module can give false negatives
disable=F0401,W0511,E0401,I1101,R0903

#   R0903 = Too few public methods
#   R0914 = Too many local variables

[SIMILARITIES]

# Minimum lines number of a similarity.
min-similarity-lines=4


[MISCELLANEOUS]

# List of note tags to take in consideration, separated by a comma.
notes=FIXME,STUB,TODO,NOTE,BUG

================
File: README.md
================
# mybots

A robotics simulation project using PyBullet and neural network control. This repository contains everything you need to build and run the simulation.

## Setup Instructions

### 1. Clone the Repository

```bash
git clone https://github.com/aaronperkel/mybots.git
cd mybots
```

### 2. Create a Python Virtual Environment

```bash
python3 -m venv venv
source venv/bin/activate
```

### 3. Install Dependencies

```bash
pip install --upgrade pip
pip install -r requirements.txt
```

### 4. Install the Package

```bash
python setup.py install
```

### 5. Running the Simulation
```bash
python scripts/search.py
```

## Helpful Scripts
### 1. Generate URDF/SDF Files
```bash
python scripts/generate.py
```

### 2. Running the Simulation
```bash
python scripts/simulate.py
```

================
File: requirements.txt
================
numpy
matplotlib
pybullet
setuptools

================
File: setup.py
================
from setuptools import setup, find_packages

setup(
    name="mybots",
    version="0.1",
    packages=find_packages(),
)
